Hey everyone my name is Greg Hogg and welcome to my channel today we'll be forecasting Microsoft stock using LSTM neural networks this is a very important project to put on your resume
大家好，我叫格雷格-霍格，欢迎来到我的频道，今天我们将使用LSTM神经网络对微软的股票进行预测，这是一个非常重要的项目，可以放在你的简历上。

so i'd really highly recommend watching the video in its entirety i made it as clear and concise as i possibly could
所以，我真的强烈建议你完整地观看这段视频，我尽可能地让它变得清晰和简明。

so i really think you're going to find this useful enjoy the video i'll see you in there.
所以我真的认为你会发现这很有用，享受视频，我会在那里看到你。

We first want to grab the dataset which we can get from this Yahoo Finance link here which will bring us to Microsoft Corporation stock page we can scroll down and change the time period from one year to max to get all of the information and then click apply we want to download which will bring a csv to your computer we need to bring that csv into our environment so in google collab we go here and then upload the file we can simply rename it by deleting those extra characters and pressing enter so we will do import pandas as pd and make df equal to dot read csv passing the file name of msft.csv close that and then outputting df 9082 rows of stock information it goes all the way from the beginning 1986 all the way till now today which is 2022 march 23rd if you're following along you might see a different date here closer to your today notice that we don't trade stocks every single day there's a gap here 19 and 20 don't exist and many other pieces in the middle don't exist as well that is okay looking at the different columns of the data set we have the date and on that date what the stock opened at the highest value for that day the lowest value for that day what it closed at the adjusted closing value and then the volume of stocks traded that day we're going to keep things simple by just using the closing value so we'll have the date and what that value was at the end of that date we're going to discard the other columns we can do that by doing df is equal to df and just the name of those two columns which is date and then close we'll set that and then outputting df we should see only those two different columns we currently have a problem with our date column as it's actually not a date it's just a string that has the year then the month then the day we can see this if we type df sub date we should see name of date except it's a d type of object we want that to be a date we usually use this thing called date time so we will import date time and then make a function so we will define a function called string to date time which is going to take a string s which will be any of these strings here any string that looks like this we're going to pass that to the function in s and it's going to return the associated date time for that string so in this function we'll create a variable called split and set that equal to the s dot split the hyphen which is the separator for each of these so a split is going to be the list of the year and then the month and then the day we can extract those three pieces year month and day equal to the split of zero split of one and split of two these objects are actually strings right now we want to make them integers so we'll just wrap each of them in int
我们首先要抓取数据集，我们可以从这个雅虎财经的链接中获得，这将把我们带到微软公司的股票页面，我们可以向下滚动，将时间段从一年改为最长，以获得所有的信息，然后点击应用，我们要下载，这将带来一个 csv到你的电脑上，我们需要把这个csv带到我们的环境中，所以在google collab中，我们去这里，然后上传文件，我们可以通过删除那些多余的字符并按回车键来简单地重命名它，所以我们将做导入pandas作为pd，使df等于dot读取csv，传递文件名msft。 csv关闭，然后输出df 9082行股票信息，从1986年开始一直到今天，也就是2022年3月23日，如果你在关注，你可能会看到这里有不同的日期，更接近你的今天，注意，我们不是每天都在交易股票，这里有一个缺口，19和20不存在，中间的许多其他部分也不存在，没关系，看看数据集的不同列，我们有日期，在那个日期，股票以最高值开盘 当天的最低值，当天的收盘价，调整后的收盘价，然后是当天的股票交易量，我们要保持简单，只使用收盘价，所以我们会有日期和该日期结束时的价值，我们要放弃其他的列，我们可以通过做df等于df，只用这两列的名字，即日期和收盘，我们会设置，然后输出df，我们应该只看到这两个不同的列，目前有一个 我们的日期列有一个问题，因为它实际上不是一个日期，它只是一个字符串，有年、月、日，我们可以看到这一点，如果我们输入df的子日期，我们应该看到日期的名称，但它是一个d类型的对象，我们希望它是一个日期，我们通常使用这个叫做日期时间的东西，所以我们将导入日期时间，然后制作一个函数，我们将定义一个叫做字符串到日期时间的函数，它将接受一个字符串s，它将是这里的任何一个字符串，看起来像这样，我们将把它传递到 它将返回该字符串的相关日期时间。因此，在这个函数中，我们将创建一个名为split的变量，并将其设置为s点分割连字符，这是每个字符串的分隔符。

so we can just return the datetime.datetime and then pass the year equal to our year the month equal to our month and the day equal to our day we'll now test out our function by creating an object called date time underscore object equal to the string to date time so calling our function and we'll pass the first day in our data set which happens to be 1986-03-19 if we output this date time object we should see that it outputs datetime.datetime of 1986 319 and this is for the time
所以我们可以直接返回datetime.datetime，然后把年传给我们的年，把月传给我们的月，把日传给我们的日，现在我们通过创建一个名为date time的下划线对象来测试我们的函数，该对象与date time的字符串相等，所以调用我们的函数，我们将传递我们数据集中的第一天，刚好是1986-03-19，如果我们输出这个date time对象，我们应该看到它输出1986 319的datetime.datetime，这是为时间准备的。

but we don't need any of that now what we need to do is apply this function to everything in our date column because we have in df this whole date column we want to make all of these date strings actual date objects so we'll set df subdate equal to itself so df subdate dot apply so we're applying a function to that column just the one that we made above we can pass string to date time into this function note that we're not calling the function here we're passing the function itself to the supply function now if we were to output our data frame column again df sub date should now show us the following it looks like this is an error but this is just a warning this is okay
但我们不需要这些，现在我们需要做的是将这个函数应用于我们的日期列中的所有内容，因为我们在df中拥有整个日期列，我们想将所有这些日期字符串变成实际的日期对象，所以我们将df subdate设置为等于自己，所以df subdate dot apply，所以我们正在将一个函数应用于该列，只是一个 我们在上面做了一个函数，我们可以把日期时间的字符串传给这个函数，注意，我们不是在这里调用这个函数，而是把这个函数本身传给供应函数。

it looks like our column is the same as it was before but actually the d type is now date time 64.
看起来我们的列和以前一样，但实际上现在的d类型是日期时间64。

this is just what pandas converts it to this is actually what we want our data frame is almost ready we just have one more step if you look at df you can see that it's index this column right here is actually integers we want to replace that column and make that date column the index we can do that very easily by setting df.index equal to the df.pop which means we take away the column and return it so df.pop passing the date and then outputting df we'll see that it did exactly what we desired make that date column the index
这只是pandas转换的结果，这实际上是我们想要的，我们的数据框架已经准备好了，我们只需要再做一步，如果你看一下df，你可以看到它的索引，这一列在这里实际上是整数，我们想替换这一列，让日期这一列成为索引，我们可以很容易地通过设置df.index等于df.pop来实现，这意味着我们拿走这一列并返回它，所以df.pop传递日期，然后输出df，我们会看到它完全实现了我们想要的，让日期这一列成为索引。

and then we just have the closing value as a column now that we did that we can quickly plot our data using matplotlib if we do import matpotlib.pyplot as plt we can do a plt.plot of the df.index and the df sub close what we can see is from 1986 all the way up until 2022 the stock goes absolutely crazy after it hits about 2016 or so
然后我们把收盘价作为一列，现在我们做了这个，我们可以用matplotlib快速绘制我们的数据，如果我们把matpotlib.pyplot导入为plt，我们可以对df.index和df.sub close做plt.plot，我们可以看到，从1986年一直到2022年，股票在达到2016年左右的时候绝对疯狂。

and then there's a little bit of a drop at the end now because we're using the lstm model we need to convert this into a supervised learning problem we're going to do this by making a new function we'll call it define df to windowed df
然后在最后有一点下降，因为我们使用的是LSTM模型，我们需要把这个问题转换为监督学习问题，我们要做的是建立一个新的函数，我们叫它define df到windowed df

it's going to take the data frame which will just pass df it'll take a first date string and a last date string and then a positive integer we'll set it equal to 3 by default this function is also going to need numpy
它将接受一个数据框架，这将直接传递给df，它将接受一个第一个日期字符串和最后一个日期字符串，然后是一个正整数，我们将把它默认设置为3，这个函数也将需要numpy

so we're going to import numpy as np now it turns out that this code is extremely difficult to write
所以我们要把numpy导入为np，现在事实证明，这段代码非常难写

so i'm going to just go in here and paste in the code if you need to know what that code is make sure you go to the video description and check out the tutorial and look at it there i also pasted in how to create this object called window df which is calling this function with certain parameters i'll explain that very shortly i just need to show you the result of window df window df is now a data frame where we have a target date column a target minus 3 minus 2 minus 1 and then the target these are all the stock closing values from before so this target date corresponds to that value here if we look above at 3 18 it should be 0.099 so 0 3 18 let's take it one more time for me to remember oh 3 18 is 0.099 why don't we have this row that row and that row well that is all about what this windowed function is so this window data frame is converting a date into getting its three previous values and then what it actually was so if we go back again 0.097 if we look at what .097 is that is three days before this is the target date this is three days before if we were to look at target minus two this would be target minus two for that date and this is target minus 1 and this is the target we have that for every single date that it allows for so of course we couldn't have dates previous than this because we didn't have a whole three values before it this was the first date that we could start with hence we actually called that as the starting date there as the last date that's the last one we wanted which is right here the three previous and then its target value right there the reason i started calling it target is to think about this column as the output because that's what our machine learning model needs we have what led up to it so three days before two days before one day before what is our corresponding output because this is the input that's fed into the model and this is the corresponding output it's just like a regression problem or any other supervised learning problem you have an input and then you have an output you have another input you have another output this is just the whole data frame which displays the inputs the outputs and the corresponding date for that output so that was really how we converted this problem to a supervised learning problem we set up its output date with that output and its corresponding input for that row now we just need to convert this into numpy arrays so that we can feed it directly into a tensorflow model so to do that we're going to create a function we're going to call it windowed df
所以我打算在这里粘贴代码，如果你需要知道代码是什么，请确保你去看视频描述并查看教程，在那里我还粘贴了如何创建这个名为window df的对象，它是通过某些参数调用这个函数的，我会解释一下。我只需要向你展示window df的结果 window df现在是一个数据框架，我们有一个目标日期栏，一个目标减去3减去2减去1，然后是目标，这些都是以前的股票收盘值，所以这个目标日期对应于这个值，如果我们看上面的3 18，它应该是0。 099，所以0 3 18让我们再来一次，让我记住哦，3 18是0.099，为什么我们没有这一行，那一行和那一行呢，这都是关于这个窗口函数的，所以这个窗口数据框是将一个日期转换为获得它之前的三个值，然后它实际上是什么，所以如果我们再次回到0.097，如果我们看一下什么。 097是三天前，这是目标日期，这是三天前，如果我们要看目标减二，这将是该日期的目标减二，这是目标减一，这是目标，我们对它允许的每一个日期都有这个目标，所以当然我们不可能有比这更早的日期，因为我们没有整整三个值，这是我们可以开始的第一个日期。这是我们可以开始的第一个日期，因此我们实际上把它称为起始日期，那里是最后一个日期，这是我们想要的最后一个日期，就在这里，之前的三个日期，然后是它的目标值，我开始把它称为目标的原因是把这一列看作是输出，因为这是我们的机器学习模型所需要的，我们有导致它的因素，所以前三天 前两天，前一天，我们的对应输出是什么，因为这是输入到模型中的输入，这是对应的输出，这就像回归问题或其他监督学习问题一样，你有一个输入，然后你有一个输出，你有另一个输入，你有另一个输出。这就是我们将这个问题转换为监督学习问题的真正方法，我们为该行的输出和对应的输入设置了输出日期，现在我们只需要将其转换为小数组，这样我们就可以将其直接输入到tensorflow模型中，所以为了做到这一点，我们将创建一个函数，将其称为windowed df

so it takes a window df like above and converts it to date x y
因此，它需要一个像上面那样的窗口df，并将其转换为日期x y

okay so this is actually three things we're going to get a list of dates we're going to get an input matrix x
好的，这实际上是三件事，我们将得到一个日期列表，我们将得到一个输入矩阵X

actually it's going to be a three-dimensional tensor we'll see shortly and y is going to be the output vector so x is going to be this matrix here except it's actually going to be three-dimensional y is going to be this output vector here and dates we want to keep those so dates is going to be this column here this function is just going to take one parameter called window data frame first is going to do df as numpy it's going to convert the whole data frame into a numpy array we do that with windowed data frame dot 2 underscore numpy bracket bracket to get the dates it's very easy we just set dates equal to df underscore as numpy and then we need to get all of the rows so we put a colon
实际上，它将是一个三维张量，我们很快就会看到，而y将是输出向量，所以x将是这里的矩阵，只不过它实际上将是三维的。 维的y将是这个输出向量，日期我们要保留这些，所以日期将是这里的这一列，这个函数只是要接受一个参数，叫做窗口数据框，首先要把df转换成numpy，它要把整个数据框转换成numpy数组，我们用窗口数据框点2下划线numpy括号来获得日期，这很简单，我们只需要把日期设置为df下划线作为numpy，然后我们需要获得所有的行，所以我们放一个冒号

and then we put 0 to say just the first column because it's this column right here getting the input matrix is a little bit more confusing so we're going to call it first middle matrix not our final input matrix middle matrix is equal to df underscore as numpy
然后我们把0说成只是第一列，因为是这一列，在这里得到的输入矩阵有点混乱，所以我们要把它称为第一中间矩阵，而不是我们的最终输入矩阵中间矩阵等于df下划线作为numpy

and again we want all the rows so we'll put a colon
我们再次想要所有的行，所以我们要加一个冒号

but we only want to start at the first column because we don't want that date column and then we want to go up until but not include the last one so 1 until negative 1 says all of these rows here that's what the colon does and then 1 to negative 1 says just this piece of information in the middle so all of this piece now unfortunately what you'll find if you go through like that is that it's actually the wrong shape for the lstm we need x is equal to middle matrix
但我们只想从第一列开始，因为我们不想要日期这一列，然后我们想一直到最后一列，但不包括最后一列，所以1到负1表示所有这些行，这就是冒号的作用，然后1到负1表示只有中间的这部分信息，所以所有这部分现在不幸的是，如果你这样去看，你会发现它实际上是LSTM的错误形状，我们需要X等于中间矩阵。

but then we need to do a reshape so we'll do a reshape where the first dimension is the length of dates so this is the number of observations that's pretty common for any tensorflow model
但是，我们需要做一个重塑，所以我们要做一个重塑，第一个维度是日期的长度，所以这是任何tensorflow模型都很常见的观察数量。

but now we need the second piece of this shape to be middle matrix dot shape sub 1.
但现在我们需要这个形状的第二块是中间的矩阵点形状子1。

that's just however many columns we had and it would be the same as that n
这只是我们有多少列，它将是相同的n

our window value i'm just making it this because we have access to that the last piece just has to be a 1 here because we are technically only using one variable we have three different values of that variable and how it changes over time
我们的窗口值，我只是把它变成这样，因为我们可以访问它，最后一块必须是1，因为技术上我们只使用一个变量，我们有三个不同的变量值，它是如何随时间变化的。

but we're still only doing what we call univariate forecasting because we're just looking at how the closing value changes over time if instead we had used some of those values at the very beginning like the open the high the volume and those variables
但我们仍然只是在做所谓的单变量预测，因为我们只是在看收盘价随时间的变化，如果我们在一开始就使用其中的一些数值，如开盘价、最高价、成交量和这些变量的话

well then we'd have to put a different number down here we'd have to put two or three or four as this number we're just doing one because we're doing univariate forecasting now luckily from here this function is very easy we can just get our output vector y is equal to df as numpy where again we want all of the rows
那么，我们必须在这里放一个不同的数字，我们必须把两个或三个或四个作为这个数字，我们只是在做一个，因为我们在做单变量预测，现在幸运的是，从这里这个函数非常简单，我们可以得到我们的输出向量y等于df作为numpy，我们希望所有的行都是如此

but we only want the last column that we can just do return three things dates x and y there's just a minor difficulty if you go on later you'll see that has an error that we can fix with dot as type float 32 actually np dot float32 if we change those for x
但我们只想要最后一列，我们可以只返回三样东西，日期为x和y，只是有一个小困难，如果你继续下去，你会看到有一个错误，我们可以用点来解决，类型为float32，实际上是np dot float32，如果我们改变这些x

and you also do that for y y dot as type numpy.float32 you'll fix a weird error you'll find later now to call this function we again want those three things we'll get dates x and y and set that equal to windowed df to date x y
你也要对y做这样的处理，y点为numpy.float32类型，你将修正一个奇怪的错误，你将在后面发现，现在要调用这个函数，我们又要这三样东西，我们将得到日期x和y，并将其设置为windowed df到日期x y

just our function there and we'll pass in our window df from before these three things should be numpy arrays so we will get dates.shape x dot shape and y dot shape and see that we have 9079 of each of these three things our input matrix and then three by one because we're looking three steps in the past but for only one type of variable now we're going to split the data into train validation and testing partitions the training will train the model the validation will help train the model and then the testing is what we're going to use to really evaluate the performance of the model we need two integers to help with the split we'll get q80 first that's going to be the integer of the length of dates times 0.8 then we'll get q90 which is equal to the int of the length of dates times 0.9
就是我们的函数，我们将传入之前的窗口df，这三样东西应该是numpy数组，所以我们将得到日期。 shape x dot shape和y dot shape，看到我们有这三样东西中的9079个，我们的输入矩阵，然后是三个一，因为我们正在寻找过去的三个步骤，但只有一种类型的变量，现在我们要把数据分成训练验证和测试两部分。训练将训练模型，验证将帮助训练模型，然后测试是我们要用来真正评估模型的性能，我们需要两个整数来帮助分割，我们将首先得到q80，它将是日期长度的整数乘以0。 8，然后我们将得到q90，这等于日期长度的整数乘以0.9。

so we'll make the training partition the first 80 percent so we'll get dates train x train and y train each of those are going to be each of their pieces so this will be dates but then only up until q80 to make it the first 80 percent we'll do the same thing with x so x up until q80 and then y up until q80 because it's a little bit slow
所以我们将使训练分区成为前80%，所以我们将得到日期训练X训练和Y训练，每一个都将是他们的每一块，所以这将是日期，但只到q80，使其成为前80%，我们将对X做同样的事情，所以X到q80，然后Y到q80，因为它有点慢。

i'm just going to paste in these two lines to get vowel and test which we can get val dates val x file and y about by going dates q 80 to q 90 then x q a to q 90 and y q to q82 q90
我只是要把这两行粘贴在一起，以获得元音和测试，我们可以通过日期q 80到q 90，然后x q a到q 90和y q到q82 q90来获得val dates val x file和y about。

that's all that information between the 80 and 90 pieces then we just get the testing information by saying q90 onward to get that last 10 so you can see it's ordered the first training piece is up until the first eighty percent the validation is the eighty to ninety percent ten percent and then the test is that final ten percent from the ninety onward we can visualize and color this very well with matplotlib
这是80和90之间的所有信息，然后我们通过说q90来获得测试信息，以获得最后的10，所以你可以看到它是有序的，第一个训练片是直到第一个80%，验证是80%到90%的10%，然后测试是最后的10%，从90%开始，我们可以用matplotlib很好地可视化和着色。

so we'll do plt.plot then we're going to get dates train and then y train we'll do the same so plt.plot for val so dates underscore val and y val finally the same for test plt.plot dates test and y test and we'll just add in a legend so that you can see which is which although it should be pretty obvious plt.legend
所以我们将做plt.plot，然后我们将得到日期train和y train，我们将做同样的事情，所以plt.plot用于val，所以日期underscore val和y val，最后同样用于test plt.plot日期test和y test，我们将添加一个图例，这样你可以看到哪个是哪个，尽管它应该很明显 plt.legend

train then validation then test if you plot that you're going to see that train is all this information here marked by the blue then validation is this piece and then test is this piece here it's time to create and train our model we can do a few imports from tensorflow from tensorflow.comstep models get sequential we're going to build a sequential model from tensorflow.curious.optimizers we'll get atom that's the optimizer we're going to use and then from tensorflow.kira's import layers we'll make a model that is sequential and built up of many layers so we'll define our model and we're going to call it model is equal to a sequential
如果你绘制这个图，你会看到，训练是这里所有的信息，由蓝色标记，然后验证是这一块，然后测试是这一块，现在是时候创建和训练我们的模型，我们可以从tensorflow做一些导入，从tensorflow。 我们将从tensorflow.comstep模型中获取顺序模型，我们将从tensorflow.curious.optimizers中获取atom，这是我们要使用的优化器，然后从tensorflow.kira的导入层中，我们将建立一个顺序模型，由许多层组成，所以我们将定义我们的模型，我们将把它称为模型等于一个顺序的

and then we'll pass that a list of layers so the first one is just the input layers dot input and we need to specify the shape of the input
然后我们将传给一个层的列表，所以第一个列表只是输入层的点输入，我们需要指定输入的形状

remember we don't need to specify the batch number or how many examples three by one again it's three because we're doing three days in the past and that's one because we need only one feature only univariate forecasting now that we've specified the input layer we're ready to do an lstm layer so we will do layers dot lstm and capitals and this number is relatively arbitrary
请记住，我们不需要指定批号或多少个例子，三乘以一，这是三个，因为我们在过去做三天，这是一个，因为我们只需要一个特征，只有单变量预测，现在我们已经指定了输入层，我们准备做一个lstm层，所以我们将做层点lstm和首都，这个数字是比较随意的。

but we will choose 64 which is a relatively big but not super big number of neurons for the lstm all that you really need to know about this number is the bigger the number the more complicated the model is the more prone it is to overfitting and the more heavy duty it is considered we will add instead of an lstm a dense layer layers.dense will choose 32 for a similar reason as above you're also very welcome to stack dense layers and so we'll just actually paste that in again and have another 32.
但我们将选择64个，这是一个相对较大但不是超级大的lstm的神经元数量，你真正需要知道的是这个数字越大，模型就越复杂，就越容易过度拟合，就越重任在肩，我们将添加一个lstm而不是一个密集层层。密集层将选择32，原因与上面类似，你也非常欢迎堆叠密集层，所以我们实际上只是再次粘贴，有另外32。

we're not going to mess with the activation functions for the lstm but for the dents it's usually a good idea to set activation equal to relu
我们不打算改变LSTM的激活函数，但对于凹痕来说，通常是一个好主意，将激活值设为重合值。

so we will do that for both of those dense layers now we must specify the output of our model and since we are only forecasting one variable we're just trying to predict say the next value we only want this to be a layers dot dense of one where we don't change the activation function as by default it's linear which is desired we can now close this up and specify that the model is going to be compiled to compile the model we must set the loss function and the loss function we want to minimize is the mean squared error so we will just write the string of mse for mean squared error we also need to specify the optimizer so we will set the optimizer equal to the atom optimizer where we specify that the learning rate is equal to for this example it turns out that 0.001 is going to work out pretty well if you're doing a different problem the learning rate is something you definitely want to play around with as well as these values here we also want to specify a new metric is going to be metrics equals we need to put it in a list it's the mean absolute error this number tells us on average how much we're off by rather than the squared distance we'd rather look at this although we need to minimize the mse as this is not differentiable we're now ready to fit the model so we can do model dot fit we pass our inputs of x train and y train
现在我们必须指定我们模型的输出，因为我们只预测一个变量，我们只想预测下一个值，所以我们只想让它成为一个密集层，我们不改变激活函数，因为默认情况下它是线性的，这是我们需要的。我们必须设置损失函数，我们想要最小化的损失函数是平均平方误差，所以我们只需写出平均平方误差的字符串mse，我们还需要指定优化器，所以我们将优化器设置为原子优化器，我们指定学习率等于这个例子中的0。 001的效果很好，如果你在做一个不同的问题，学习率是你肯定想玩的东西，以及这些值，我们还想指定一个新的指标，就是指标等于我们需要把它放在一个列表中，这是平均绝对误差。这个数字告诉我们平均偏差有多大，而不是距离的平方，我们更愿意看这个，尽管我们需要最小化mes，因为这不是可微调的，我们现在准备好拟合模型，所以我们可以做模型点拟合，我们把x训练和y训练的输入传给

and then we specify that the validation data is equal to the tuple of x val and y val we're going to let this run for 100 epochs which means 100 runs through the data set
然后我们指定验证数据等于x val和y val的元组，我们要让它运行100个epochs，也就是在数据集中运行100次。

i'm going to press enter
我将按下回车键

and we can see what happens as we can see at this point it looks like it's not really changed very much so we can actually cancel this and it is going to save whatever progress it's done so far now to briefly analyze this we mostly care about the validation mean absolute error going down we can see it's at 14 at the beginning then it goes to 11 10 9
我们可以看到发生了什么，我们可以看到在这一点上，它看起来并没有什么变化，所以我们实际上可以取消这个，它将保存到目前为止所做的任何进展，现在简单分析一下，我们主要关心的是验证平均绝对误差的下降，我们可以看到它在开始时是14，然后是11 10 9

and then it hovers around 8 9 10 and that's when i was ready to stop it because it wasn't really changing all that much
然后它在8-9-10左右徘徊，这时我准备停止它，因为它并没有真正改变什么。

it's much easier to visualize what's going on instead with graphs so before worrying about the code i'm just going to show you the pretty picture we can make for it predicting on the training set so the orange is the actual observed observations it's what really happened from 1986 to 2016.
在担心代码之前，我只想向你展示我们可以在训练集上预测的漂亮图片，所以橙色是实际的观察结果，是1986年到2016年的真实情况。

the blue is what we predicted so each time it got the three previous and it tried to predict the next one that's also what it was trained on to make that run we simply get the training predictions with model.predict on x train and then we have to do a flatten then we can do a plot of dates train and the train predictions and dates train and y train that's that blue and the orange curve
蓝色是我们预测的结果，所以每次它得到之前的三个，并试图预测下一个，这也是它被训练的结果，为了使其运行，我们简单地用model.predict在x train上得到训练预测，然后我们必须做一个扁平化，然后我们可以做一个日期训练和训练预测的图，日期训练和y训练，这就是蓝色和橙色的曲线。

and then we just create the legend since i explained that code for the train i feel no real need to explain it much for the validation as this is literally the same thing but replacing the word train with val so for the validation we get this graph or it follows it until you know about 2017
然后我们就创建图例，因为我解释了火车的代码，所以我觉得没有必要对验证进行过多的解释，因为这实际上是同样的事情，只是把火车这个词换成了Val，所以对于验证来说，我们得到了这个图，或者说它跟它一样，直到你知道2017年的情况。

and then it just really flattens off which is the same time when it actually starts to pick up so the observations what really happened is it went up like this but the predictions it actually just started to zone off and it couldn't follow it anymore if we were to look at the test this is again just replacing that word train with test this picture is even worse it doesn't follow it at all it actually thinks it's going down a little bit whereas it's going up a lot
然后它就真的变平了，这也是它真正开始回升的时候，所以观察到的真实情况是它像这样上升了，但预测它实际上只是开始变平了，它不能再跟随它了，如果我们看一下测试，这又是把火车这个词换成测试，这幅图更糟糕，它根本不跟随它，它实际上认为它在下降一点，而它却上升了很多。

and then it goes down
然后它就下降了

i'm now going to put all three of those pictures on the same graph again the code is not hard it's just annoying where we first plot the training predictions and the observations the validation predictions and the observations same for the test
我现在要把这三张图片放在同一张图上，代码并不难，只是很烦人，我们首先绘制训练预测和观察结果，验证预测和观察结果，对测试也是如此。

and then we create the legend we see that this picture again for the training it follows it very closely and for the red piece is what actually happened in validation the green is what it thought happened not good at all the brown is what really happened and the purple is what it thought for the test really really bad at that point it turns out that these lstm models are very bad at what we call extrapolating and so if it was trained on data only in this range here only up until like the 50 value it's not going to be good at predicting stuff this high even though it is given say his input these three values here and has no idea what to do with them because it's not going to extrapolate well extrapolate means basically learn data outside its range a line extrapolates well because if we drew a line here we could just continue drawing that line up like that but if the lstm is only trained on this data here it will have no idea what to do when the values are increasing and are this big another way to think about it is that all this information here it might actually not be that helpful because over here the values are way up like this and the pattern starts changing a lot
然后我们创建图例，我们看到这张图又是训练的，它非常紧跟它，对于红色部分是验证中实际发生的情况，绿色是它认为发生的情况，一点也不好，棕色是真正发生的情况，紫色是它认为测试的情况，真的非常糟糕，在这一点上，事实证明，这些LSTM模型非常不擅长我们所说的外推，所以如果它只在这个范围内训练数据，直到像50值，它不会擅长预测这么高的东西，尽管它被给予说他的输入这三个值，不知道该怎么办，因为它不会外推。输入这三个值，但它不知道该怎么做，因为它不会外推，外推的意思是基本上学习其范围以外的数据，一条线可以很好地外推，因为如果我们在这里画一条线，我们就可以继续这样画下去，但如果lstm只在这里的数据上训练，当数值增加到这么大时，它就不知道该怎么做了，另一种思考方式是，这里的所有信息实际上可能没有什么帮助，因为在这里，数值像这样一路上升，模式开始变化很多

so maybe we don't want to train it on all of this maybe we just want to train it on say this information here and then validate over here so we'll do just that we're going to pick some day over here to start training at we do need to know that this date is actually in the data set and for that we'll go to our data set over here and select the time period of one year and if we apply that we just need to scroll back all the way to the bottom and see that one date that we know exists is march 25th 2021 we will use that as our starting value instead so that means we need to change our windowed function above or not actually change the windowed function itself but just change how we're calling it we need to change this value here to be the year is going to be 2021 03 is fine and then 2 5 is a date we know exists as you can see here i had this in a comment for me to remember so now the first date will be 2021 0325 and these are its corresponding information the end date is exactly the same and we only have 252 rows this time way less information we should have no problem just re-running the cells we already did so we're going to do that which gets dates x and y note that they're smaller this time we'll again split the data set and make sure that we plot it properly so our starting date up until about the middle over here is train then validation then test and note that we've already seen values in this range so it should be okay to predict values in the same range over here since we only change the number of things the model is seeing the model is actually fine as is we can run that again and it's going to run a lot faster now we'll see again that our mean absolute error goes down pretty low and for the validation a lot better than it was before we can recreate all of our graphs so to plot the training we can see here the train it doesn't follow it quite as well as before but that's totally okay if we see here for the validation it got so much better now look at how zoomed in this is these values are extremely close to each other and if we were to do it for the test as well the tests are also extremely close to each other if we were to plot them all on the same graph again we would see here zoomed out that they're all very close to each other the predicted first the observation is very very close no matter whether it's the train the validation or the test now the video could be done here
所以也许我们不想对所有这些进行训练，也许我们只想对这些信息进行训练，然后在这里进行验证，所以我们就这样做，我们要在这里选一个日子开始训练，我们需要知道这个日期确实在数据集中，为此我们要去我们的数据集，选择一年的时间段，如果我们应用这个，我们只需要一直滚动到底部，看到一个我们知道存在的日期是2021年3月25日，我们将使用这个作为起始值 因此，这意味着我们需要改变上面的窗口函数，或者不改变窗口函数本身，而只是改变我们的调用方式，我们需要改变这里的值，年份将是2021年03月，很好，然后2 5是一个我们知道存在的日期，你可以在这里看到，我有这个评论让我记住，所以现在第一个日期将是2021年0325，这些是它的对应信息，结束日期是完全相同的，我们只有252行，这次的信息少，我们应该没有问题，只是重新 运行我们已经做过的单元格，所以我们要做的是得到日期x和y，注意它们更小了，这次我们将再次分割数据集，并确保我们正确地绘制它，所以我们的起始日期到中间的位置是训练，然后是验证，然后是测试，注意我们已经看到了这个范围内的值 所以在相同的范围内预测数值应该是没问题的，因为我们只改变了模型看到的东西的数量，模型实际上是很好的，我们可以再次运行，它的运行速度会快很多，现在我们会再次看到我们的平均绝对误差下降得很低，对于验证来说，比以前好很多。我们可以重新制作我们所有的图表，所以要绘制训练图，我们可以看到这里的训练图并不像以前那么好，但这完全没问题，如果我们看到这里的验证图，它变得好得多，现在看这是如何放大的，这些值非常接近。如果我们对测试也这样做，测试也是非常接近的，如果我们把它们都画在同一张图上，我们会看到在这里放大后，它们都是非常接近的，不管是训练、验证还是测试，预测先于观察是非常非常接近的，现在视频可以在这里完成

but i want to show you how you could try and predict long term because all of these values any of these predictions we're assuming we had the actual three days before and that data was real then we used those three days before to make the prediction and then the next day we would have the actual three
但我想告诉你，你可以尝试长期预测，因为所有这些价值，任何这些预测，我们假设我们有前三天的实际数据，而且这些数据是真实的，然后我们用前三天的数据进行预测，然后第二天我们会有实际的三天数据。

and then we'd use that predict the next day well what we're actually going to do is train here and then pretend that's all the data that we have and let the model recursively predict the future and see what it has to say so to make that function we're first going to do from copy import deep copy we'll make a list and start to build this up called recursive predictions is equal to an empty list and then we'll get recursive dates these are the dates on which we're predicting for this is already known and this is equal to np dot concatenate the dates val and the test val this is because the dates we're predicting are here onward so we're training on all of this in fact we've already trained on all of that and then the recursive predictions are going to be for these following dates so now we can loop through those dates for target date in the recursive dates we'll get our most recent input so the last we'll call it window
我们实际上要做的是在这里进行训练，然后假装这是我们拥有的所有数据，让模型递归地预测未来，看看它能说些什么，所以要制作这个函数，我们首先要从copy import deep copy中做一个列表，开始建立这个叫做递归预测的列表，等于一个空列表，然后我们会得到递归日期，这是我们正在预测的日期。递归预测，这是已经知道的，这等于np点串联日期val和测试val，这是因为我们预测的日期是在这里开始的，所以我们对所有这些进行训练，事实上我们已经对所有这些进行了训练，然后递归预测将是对以下这些日期，所以现在我们可以通过这些日期进行循环，在递归日期的目标日期，我们将得到我们最近的输入，所以最后我们将它称为窗口

i'm just copying it so we don't change anything deep copy of x train sub negative one because the last window that we actually had access to was the very last three over here that is stored in x trains of negative one and we need to start predicting for the future so we need to get our next prediction so the prediction for the next day that will be equal to model.predict unfortunately we actually have to make it the numpy.array of the list of the last window
我只是复制了它，所以我们没有改变任何东西 深度复制x train sub negative one，因为我们实际上可以访问的最后一个窗口是这里的最后三个，它被存储在x trains of negative one中，我们需要开始预测未来，所以我们需要得到我们的下一个预测，所以第二天的预测将等于model.predict，不幸的是我们实际上必须使它成为最后一个窗口的numpy.array列表。

but really it's just the last window don't worry too much about that piece that and then flatten it like before then what we can do is recursive predictions dot append
但实际上，这只是最后一个窗口，不用太担心，然后像以前一样把它压平，我们可以做的是递归预测点追加。

so add that to our list with next prediction then we need to update this last window because we just made a prediction for the next day
所以将其添加到我们的下一个预测列表中，然后我们需要更新最后一个窗口，因为我们刚刚对第二天进行了预测。

well now we need to move on to the previous two informations that were actually seen and then the next predicted value because we need to start using the values that we're predicting that's why it's called recursive predicting so we'll actually set last window sub negative one equal to next prediction
现在我们需要转到实际看到的前两个信息，然后是下一个预测值，因为我们需要开始使用我们正在预测的值，这就是为什么它被称为递归预测，所以我们实际上将最后一个窗口的负数设置为等于下一个预测值。

sorry i have an error here this should actually be dates test and then if we run that i'm now going to paste in again some annoying code but it'll look very familiar it's exactly the same as that big graph as before except i added in the recursive dates and the recursive predictions and that put that in the legend as well if i were to plot this you will see something very funny this piece right here is the recursive predictions the model has absolutely no idea on how to predict in the future it just thinks it'll be what it was before and actually that's a reasonable prediction predicting stocks is incredibly difficult there is of course the trend we can analyze we saw before that the graph really started to go up and that would indicate to you that it's a good stock to buy but that doesn't mean i can guarantee that
对不起，我这里有一个错误，这实际上应该是日期测试，然后如果我们运行它，我现在要再次粘贴一些恼人的代码，但它看起来非常熟悉，它与之前的大图完全一样，只是我加入了递归日期和递归预测，并将其放在图例中，如果我绘制这个图，你会看到一些非常有趣的东西，这一块是 递归预测模型完全不知道如何预测未来，它只是认为它会像以前一样，实际上这是一个合理的预测，预测股票是非常困难的，当然，我们可以分析趋势，我们看到之前的图表真的开始上升，这将表明它是一个好的股票，可以购买，但这并不意味着我可以保证它。

and i don't want to be liable for you predicting any sort of stocks with any sort of model and by no means is the model we made useless it's just on the micro scale of per day should i sell or buy of course in general people generally think of stocks for the long term what should i do to make money in the long term but on a micro scale it's important to know as well
我不想对你用任何模式预测任何种类的股票负责，我们做的模式绝不是无用的，它只是在每天的微观规模上，我应该卖出或买入，当然，一般来说，人们通常认为股票是长期的，我应该做什么来长期赚钱，但在微观规模上，知道这一点也很重要。

so i hope you enjoyed that video if it brought you value please drop a like and consider subscribing it really really helps and i'll see you next time guys
我希望你喜欢这段视频，如果它给你带来了价值，请点个赞并考虑订阅，这真的很有帮助，我将在下一次见到你，伙计们。